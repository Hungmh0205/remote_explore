<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shared View</title>
    <style>
      body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans; margin: 0; }
      .app { padding: 12px; }
      .top { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
      .meta { font-size: 12px; color:#6b7280; }
      .pathbar { display:flex; gap:8px; margin: 10px 0; }
      input { padding:6px 8px; width:100%; }
      .toolbar { display:flex; gap:8px; margin: 8px 0; }
      .listing { border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
      table { width: 100%; border-collapse: collapse; }
      th, td { padding: 8px 10px; border-bottom: 1px solid #f3f4f6; text-align: left; }
      tr.selected { background-color: #dbeafe; }
      button { padding:6px 10px; cursor:pointer; }
      .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 1000; }
      .modal-card { width: 80vw; max-width: 900px; height: 70vh; background: #fff; border-radius: 8px; display: flex; flex-direction: column; }
      .modal-head { padding: 10px 12px; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: space-between; }
      .modal-card textarea { flex: 1; width: 100%; border: none; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; }
      .modal-content { flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; overflow: auto; }
      .modal-content img { max-width: 100%; max-height: 100%; object-fit: contain; }
      .modal-content iframe { width: 100%; height: 100%; border: none; }
      .modal-content .preview-error { text-align: center; color: #6b7280; }
      .hint { color:#6b7280; font-size:12px; }
    </style>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/axios@1.7.7/dist/axios.min.js"></script>
  </head>
  <body>
    <div id="app" class="app">
      <div class="top">
        <h2 style="margin:0">Shared</h2>
      </div>
      <div class="pathbar">
        <input v-model="currentRel" @keyup.enter="navigate(currentRel)" placeholder="Subpath (relative within share)" />
        <button @click="navigate(currentRel)">Go</button>
      </div>
      <div class="toolbar">
        <button @click="goUp">Up</button>
        <button v-if="selected.size > 0" @click="downloadSelected">Download Selected ({{ selected.size }})</button>
        <div class="hint">You can access items within this shared scope only.</div>
      </div>
      <section class="listing">
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Size</th>
              <th>Modified</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="e in entries" :key="e.path" :class="{ selected: isSelected(e) }" @click="onRowClick(e, $event)">
              <td>
                <span v-if="e.is_dir" style="font-weight:600; cursor:pointer" @dblclick="openDir(e)">üìÅ {{ e.name }}</span>
                <span v-else style="cursor:pointer" @dblclick="openFile(e)">üìÑ {{ e.name }}</span>
              </td>
              <td>{{ e.is_dir ? '' : formatSize(e.size) }}</td>
              <td>{{ formatTime(e.modified) }}</td>
              <td>
                <template v-if="!e.is_dir">
                  <button @click="downloadFile(e)">Download</button>
                </template>
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <div v-if="editor.visible" class="modal" @click.self="closeEditor">
        <div class="modal-card">
          <div class="modal-head">
            <strong>{{ editor.name }}</strong>
            <div style="display:flex; gap:8px; align-items:center">
              <button v-if="editor.type === 'text' && shareInfo && shareInfo.allow_edit" @click="toggleEdit">{{ editor.readonly ? 'Edit' : 'Read Only' }}</button>
              <button v-if="editor.type === 'text' && !editor.readonly && shareInfo && shareInfo.allow_edit" @click="saveFile">Save</button>
              <button v-if="editor.type === 'text'" @click="downloadFile({name: editor.name})">Download</button>
              <button @click="closeEditor">Close</button>
            </div>
          </div>
          <div v-if="editor.type === 'text'" class="modal-content">
            <textarea v-model="editor.content" :readonly="editor.readonly" style="width: 100%; height: 100%; border: none; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; font-size: 13px; resize: none;"></textarea>
          </div>
          <div v-else-if="editor.type === 'image'" class="modal-content">
            <img :src="editor.url" :alt="editor.name" />
          </div>
          <div v-else-if="editor.type === 'pdf'" class="modal-content">
            <iframe :src="editor.url" type="application/pdf"></iframe>
          </div>
          <div v-else class="modal-content">
            <div class="preview-error">
              <p>Preview not available for this file type.</p>
              <button @click="downloadFile({name: editor.name})">Download File</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      const { createApp, ref, onMounted, reactive } = Vue
      createApp({
        setup() {
          const token = new URLSearchParams(location.search).get('token') || ''
          const currentRel = ref('')
          const entries = ref([])
          const editor = reactive({ visible: false, path: '', name: '', content: '', type: '', url: '', readonly: true })
          const shareInfo = ref(null)
          const selected = reactive(new Set())
          let lastClickedIndex = -1

          if (!token) {
            document.body.innerHTML = '<div style="padding:20px">Missing token</div>'
          }

          async function load(rel) {
            const res = await axios.get('/api/share/list', { params: { token, path: rel || '' } })
            entries.value = res.data
            currentRel.value = rel || ''
          }
          
          async function loadShareInfo() {
            try {
              const res = await axios.get('/api/share/info', { params: { token } })
              shareInfo.value = res.data
            } catch (err) {
              console.error('Failed to load share info:', err)
            }
          }
          function navigate(rel) { load(rel) }
          function goUp() {
            const p = currentRel.value.replace(/\\+$/,'')
            const idx = Math.max(p.lastIndexOf('\\'), p.lastIndexOf('/'))
            if (idx >= 0) load(p.slice(0, idx))
            else load('')
          }
          function openDir(e) {
            const next = (currentRel.value ? currentRel.value.replace(/[\\/]+$/,'') + '/' : '') + e.name
            load(next)
          }
          function downloadFile(e) {
            const a = document.createElement('a')
            const rel = (currentRel.value ? currentRel.value.replace(/[\\/]+$/,'') + '/' : '') + e.name
            a.href = `/api/share/file?token=${encodeURIComponent(token)}&path=${encodeURIComponent(rel)}&download=true`
            a.download = e.name
            a.click()
          }
          function getFileType(filename) {
            const name = filename.toLowerCase()
            const ext = name.split('.').pop()
            
            // Text files
            const textExts = ['txt','md','log','json','xml','csv','ini','conf','yaml','yml','py','js','ts','java','c','cpp','cs','go','rb','php','bat','ps1','html','css','sql','sh']
            if (textExts.includes(ext)) return 'text'
            
            // Image files
            const imageExts = ['jpg','jpeg','png','gif','bmp','webp','svg','ico']
            if (imageExts.includes(ext)) return 'image'
            
            // PDF files
            if (ext === 'pdf') return 'pdf'
            
            return 'other'
          }
          
          async function openFile(e) {
            const rel = (currentRel.value ? currentRel.value.replace(/[\\/]+$/,'') + '/' : '') + e.name
            const fileType = getFileType(e.name)
            
            editor.visible = true
            editor.path = rel
            editor.name = e.name
            editor.type = fileType
            editor.readonly = !(shareInfo.value && shareInfo.value.allow_edit)
            
            if (fileType === 'text') {
              try {
                const res = await axios.get('/api/share/read', { params: { token, path: rel }, responseType: 'text' })
                editor.content = res.data
              } catch (err) {
                editor.content = 'Error loading file content'
              }
            } else if (fileType === 'image' || fileType === 'pdf') {
              editor.url = `/api/share/file?token=${encodeURIComponent(token)}&path=${encodeURIComponent(rel)}`
            }
          }
          
          function closeEditor() { editor.visible = false }
          
          function toggleEdit() {
            editor.readonly = !editor.readonly
          }
          
          async function saveFile() {
            try {
              await axios.post('/api/share/save', {
                token,
                path: editor.path,
                content: editor.content
              })
              editor.readonly = true
              alert('File saved successfully!')
            } catch (err) {
              alert('Failed to save file: ' + (err.response?.data?.detail || err.message))
            }
          }

          function formatSize(bytes) {
            const t=1024; if (Math.abs(bytes)<t) return bytes+' B'; const u=['KB','MB','GB','TB','PB']; let i=-1; do { bytes/=t; i++ } while (Math.abs(bytes)>=t && i<u.length-1); return bytes.toFixed(1)+' '+u[i]
          }
          function formatTime(epoch) { return new Date(epoch*1000).toLocaleString() }
          
          function isSelected(e) { return selected.has(e.path) }
          
          function onRowClick(e, event) {
            if (event.target.tagName === 'BUTTON') return
            
            const index = entries.value.findIndex(item => item.path === e.path)
            const isCtrl = event.ctrlKey || event.metaKey
            const isShift = event.shiftKey
            
            if (isCtrl) {
              if (selected.has(e.path)) {
                selected.delete(e.path)
              } else {
                selected.add(e.path)
              }
              lastClickedIndex = index
            } else if (isShift && lastClickedIndex >= 0) {
              const start = Math.min(lastClickedIndex, index)
              const end = Math.max(lastClickedIndex, index)
              selected.clear()
              for (let i = start; i <= end; i++) {
                selected.add(entries.value[i].path)
              }
            } else {
              selected.clear()
              selected.add(e.path)
              lastClickedIndex = index
            }
          }
          
          async function downloadSelected() {
            if (selected.size === 0) return
            const selectedItems = Array.from(selected).map(path => entries.value.find(e => e.path === path)).filter(Boolean)
            if (selectedItems.length === 0) return
            
            // If only one item selected, download directly
            if (selectedItems.length === 1) {
              const item = selectedItems[0]
              downloadFile(item)
              return
            }
            
            // Multiple items selected - create a temporary ZIP
            try {
              const paths = selectedItems.map(item => {
                const rel = (currentRel.value ? currentRel.value.replace(/[\\/]+$/,'') + '/' : '') + item.name
                return rel
              })
              const response = await axios.post('/api/share/zip/multiple', { 
                token, 
                paths 
              }, { responseType: 'blob' })
              const url = window.URL.createObjectURL(new Blob([response.data]))
              const a = document.createElement('a')
              a.href = url; a.download = 'selected_files.zip'; a.click()
              window.URL.revokeObjectURL(url)
            } catch (err) {
              alert('Failed to download selected files: ' + (err.response?.data?.detail || err.message))
            }
          }

          onMounted(async () => { 
            await loadShareInfo()
            await load('') 
          })
          return { currentRel, entries, navigate, goUp, openDir, downloadFile, openFile, closeEditor, toggleEdit, saveFile, editor, shareInfo, formatSize, formatTime, selected, isSelected, onRowClick, downloadSelected }
        }
      }).mount('#app')
    </script>
  </body>
  </html>


