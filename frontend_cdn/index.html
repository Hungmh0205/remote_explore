<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Remote File Explorer</title>
  <style>
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans;
      margin: 0;
    }

    .app {
      padding: 12px;
      padding-bottom: 32px;
      /* space for system bar */
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 240px;
      height: 100vh;
      background: #f8fafc;
      border-right: 1px solid #e2e8f0;
      padding: 12px;
      overflow-y: auto;
      z-index: 100;
    }

    .app {
      padding-left: 264px;
    }

    .sidebar.dragover {
      outline: 2px dashed #6366f1;
    }

    .sidebar-head {
      font-weight: 700;
      margin-bottom: 8px;
    }

    .pins {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .pin-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 4px;
    }

    .pin-item:hover {
      background: #f8fafc;
    }

    .pin-name {
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .unpin {
      border: 1px solid #e5e7eb;
      background: #fff;
      border-radius: 4px;
      width: 20px;
      height: 20px;
      line-height: 18px;
      text-align: center;
      padding: 0;
      cursor: pointer;
    }

    .sidebar-hint {
      color: #6b7280;
      font-size: 12px;
      margin-top: 8px;
    }

    .content {
      flex: 1;
    }

    .topbar {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .pathbar {
      display: flex;
      gap: 8px;
      flex: 1;
    }

    input {
      width: 100%;
      padding: 6px 8px;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      margin: 8px 0;
      align-items: center;
      flex-wrap: wrap;
    }

    .listing {
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
      min-height: 200px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 8px 10px;
      border-bottom: 1px solid #f3f4f6;
      text-align: left;
    }

    tbody tr:not(.selected):hover {
      background: #f8fafc;
    }

    .folder,
    .file {
      cursor: default;
    }

    .folder {
      font-weight: 600;
    }

    button {
      padding: 6px 10px;
      cursor: pointer;
      margin: 4px;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      transition: background 0.15s ease, transform 0.02s ease;
    }

    button:hover {
      background: #e9ebef;
    }

    button:active {
      transform: translateY(1px);
      background: #e1e4e8;
    }

    label.upload input {
      display: none;
    }

    label.upload span {
      display: inline-block;
      padding: 6px 10px;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.02s ease;
    }

    label.upload span:hover {
      background: #e9ebef;
    }

    label.upload span:active {
      transform: translateY(1px);
      background: #e1e4e8;
    }

    tr.selected {
      background: #e9ebef;
    }

    tr.drop-target {
      outline: 2px dashed #6366f1;
    }

    /* Grid View */
    .grid-view {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      padding: 12px;
    }

    .grid-item {
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      background: #fff;
      transition: 0.1s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .grid-item:hover {
      background: #f8fafc;
    }

    .grid-item.selected {
      background: #e9ebef;
      border-color: #cbd5e1;
    }

    .grid-icon {
      font-size: 48px;
      line-height: 1;
    }

    .grid-name {
      font-size: 13px;
      word-break: break-word;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    /* System Bar */
    .system-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 28px;
      background: #f1f5f9;
      border-top: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      padding: 0 12px;
      font-size: 12px;
      color: #475569;
      z-index: 200;
      gap: 16px;
    }

    .stat-item {
      display: flex;
      gap: 6px;
    }

    /* Upload Progress */
    .upload-overlay {
      position: fixed;
      bottom: 40px;
      right: 20px;
      width: 300px;
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 500;
    }

    .progress-bar {
      height: 6px;
      background: #f1f5f9;
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #6366f1;
      transition: width 0.2s;
    }

    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #e5e7eb;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      border-radius: 6px;
      min-width: 180px;
      padding: 6px 0;
      z-index: 1000;
    }

    .menu-item {
      padding: 6px 12px;
      cursor: pointer;
    }

    .menu-item:hover {
      background: #f8fafc;
    }

    .menu-item.danger {
      color: #b91c1c;
    }

    .menu-sep {
      height: 1px;
      background: #e5e7eb;
      margin: 6px 0;
    }

    details {
      padding: 0 6px;
    }

    .menu-sub {
      padding-left: 10px;
    }

    .sidebar-footer {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 15px;
    }

    a.btn {
      display: block;
      width: 100%;
      padding: 10px 12px;
      background: #f8fafc;
      border: none;
      border-radius: 6px;
      text-decoration: none;
      color: inherit;
      text-align: left
    }

    a.btn:hover {
      background: #f8fafc
    }

    a.btn:active {
      background: #e9edf3
    }

    body.dark a.btn {
      background: #111827;
      color: #e5e7eb;
      border: none
    }

    body.dark a.btn:hover {
      background: #0b1220
    }

    body.dark a.btn:active {
      background: #0a1120
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-card {
      width: 80vw;
      max-width: 900px;
      height: 70vh;
      background: #fff;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
    }

    .modal-head {
      padding: 12px 16px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
    }

    /* IDE Mode Styles */
    .modal-card.modal-ide {
      width: 95vw;
      max-width: none;
      height: 95vh;
      border-radius: 6px;
      overflow: hidden;
      /* clean edges */
      border: 1px solid #333;
    }

    .modal-card.modal-ide .modal-head {
      background: #1e1e1e;
      /* VS Code header color */
      color: #cccccc;
      border-bottom: 1px solid #333;
      padding: 8px 12px;
      font-size: 13px;
    }

    .modal-card.modal-ide .modal-body {
      padding: 0;
      /* Full edge-to-edge */
      background: #1e1e1e;
    }

    /* CodeContainer specifically */
    .code-container {
      width: 100%;
      height: 100%;
      /* Monaco handles scrolling internally, so no overflow here */
    }

    /* Standard body padding for other modals */
    .modal-body {
      padding: 16px;
      overflow-y: auto;
      flex: 1;
    }

    /* Dropdown Menu */
    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      background: #fff;
      border: 1px solid #e5e7eb;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border-radius: 4px;
      z-index: 100;
      min-width: 120px;
      padding: 4px 0;
    }

    body.dark .dropdown-menu {
      background: #1e1e1e;
      border-color: #444;
    }

    /* Drag Drop Overlay */
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(99, 102, 241, 0.15);
      border: 4px dashed #6366f1;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 600;
      color: #6366f1;
      backdrop-filter: blur(2px);
      pointer-events: none;
      /* Allow events to pass through initially, but we might need active for drop */
    }

    body.dark .drop-overlay {
      background: rgba(99, 102, 241, 0.2);
      color: #818cf8;
      border-color: #818cf8;
    }

    /* Modal Inputs */
    .modal-input {
      width: 400px;
      background: #fff;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    body.dark .modal-input {
      background: #1e1e1e;
      border: 1px solid #333;
    }

    .modal-input h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    .modal-input input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      outline: none;
    }

    body.dark .modal-input input {
      background: #2d2d2d;
      border-color: #444;
      color: #eee;
    }

    .modal-input input:focus {
      border-color: #0e639c;
    }

    .modal-input .btns {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .modal-card textarea {
      flex: 1;
      width: 100%;
      border: none;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }

    /* Dark mode overrides */
    body.dark {
      background: #0f172a;
      color: #e5e7eb;
    }

    body.dark .sidebar {
      background: #111827;
      border-color: #1f2937;
    }

    body.dark .pin-item:hover {
      background: #0b1220;
    }

    body.dark .unpin {
      background: transparent;
      color: #e5e7eb;
      border-color: #1f2937
    }

    body.dark .sidebar-hint {
      color: #94a3b8
    }

    body.dark .listing {
      border-color: #1f2937
    }

    body.dark th,
    body.dark td {
      border-color: #1f2937
    }

    body.dark tr.selected {
      background: #0b1220
    }

    body.dark tbody tr:not(.selected):hover {
      background: #0b1220
    }

    body.dark .context-menu {
      background: #0f172a;
      border-color: #1f2937
    }

    body.dark .menu-item:hover {
      background: #0b1220
    }

    body.dark button {
      background: #0b1220;
      color: #e5e7eb;
      border: 1px solid #1f2937;
      border-radius: 4px
    }

    body.dark button:hover {
      background: #0e1526
    }

    body.dark button:active {
      background: #0a1120
    }

    body.dark input {
      background: transparent;
      color: #e5e7eb;
      border: 1px solid #1f2937
    }

    body.dark label.upload span {
      background: #0b1220;
      color: #e5e7eb;
      border: 1px solid #1f2937
    }

    body.dark label.upload span:hover {
      background: #0e1526
    }

    body.dark label.upload span:active {
      background: #0a1120
    }

    /* Grid dark mode */
    body.dark .grid-item {
      background: #111827;
      border-color: #1f2937
    }

    body.dark .grid-item:hover {
      background: #0b1220
    }

    body.dark .grid-item.selected {
      background: #1e293b;
      border-color: #334155
    }

    body.dark .system-bar {
      background: #1e293b;
      border-color: #334155;
      color: #94a3b8
    }

    body.dark .upload-overlay {
      background: #1e293b;
      border-color: #334155;
      color: #e5e7eb
    }

    body.dark .progress-bar {
      background: #334155
    }

    /* Modal dark mode */
    body.dark .modal-card {
      background: #0f172a;
      border: 1px solid #1f2937
    }

    body.dark .modal-head {
      border-color: #1f2937
    }

    body.dark .modal-card textarea {
      background: transparent;
      color: #e5e7eb
    }

    .CodeMirror {
      height: 100%;
    }

    body.dark .CodeMirror {
      background: transparent;
      color: #e5e7eb
    }

    body.dark .cm-s-default .CodeMirror-gutters {
      background: #0f172a;
      border-right: 1px solid #1f2937
    }

    /* Improve CodeMirror caret/selection visibility in dark mode */
    body.dark .CodeMirror-cursor {
      border-left: 2px solid #e5e7eb !important
    }

    body.dark .CodeMirror-selected {
      background: rgba(148, 163, 184, 0.25) !important
    }

    /* Breadcrumbs and layout helpers */
    .breadcrumbs {
      font-size: 12px;
      color: #6b7280;
      margin: 8px 12px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    body.dark .breadcrumbs {
      color: #94a3b8
    }

    .breadcrumbs span {
      cursor: pointer;
      color: inherit
    }

    .spacer {
      flex: 1
    }

    .search-box {
      display: flex;
      align-items: center;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding-left: 8px;
      background: #fff;
    }

    body.dark .search-box {
      background: #0b1220;
      border-color: #1f2937;
      color: #e5e7eb;
    }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/axios@1.7.7/dist/axios.min.js"></script>
  <!-- Monaco Editor Loader -->
  <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>
</head>

<body>
  <div id="app" class="app" @dragover.prevent @drop.prevent>
    <div v-if="showDropOverlay" class="drop-overlay">
      <div>üöÄ Th·∫£ file v√†o ƒë√¢y ƒë·ªÉ Upload</div>
    </div>
    <header class="topbar">
      <h1 style="margin:0">Remote File Explorer</h1>
      <div class="pathbar">
        <input v-model="currentPath" @keyup.enter="navigate(currentPath)"
          placeholder="Nh·∫≠p ƒë∆∞·ªùng d·∫´n (v√≠ d·ª• C:\ ho·∫∑c D:\projects)" />
        <button @click="navigate(currentPath)">Go</button>

        <span class="spacer"></span>
        <button @click="toggleTheme">{{ theme === 'dark' ? 'Light' : 'Dark' }}</button>
      </div>
    </header>
    <div class="breadcrumbs">
      <template v-for="(seg, i) in pathSegments" :key="i">
        <span @click="navigate(seg.path)">{{ seg.label }}</span>
        <span v-if="i < pathSegments.length - 1">‚Ä∫</span>
      </template>
    </div>

    <div class="layout">
      <aside class="sidebar" @dragover.prevent="onSidebarDragOver" @dragleave="onSidebarDragLeave"
        @drop="onSidebarDrop">
        <div class="sidebar-head">This PC</div>
        <ul class="pins">
          <li v-for="d in drives" :key="d" class="pin-item">
            <span class="pin-name" @click="navigate(d)">üíΩ {{ displayName(d) }}</span>
          </li>
        </ul>
        <div class="sidebar-head" style="margin-top:8px">Quick Access</div>
        <ul class="pins">
          <li v-for="p in pins" :key="p" class="pin-item">
            <span class="pin-name" @click="navigate(p)">üìå {{ displayName(p) }}</span>
            <button class="unpin" @click="unpin(p)">√ó</button>
          </li>
        </ul>
        <div class="sidebar-hint">K√©o th∆∞ m·ª•c v√†o ƒë√¢y ƒë·ªÉ Pin</div>
        <div class="sidebar-footer">
          <a class="btn" href="/admin.html" style="position: relative; top: -20px">Admin</a>
          <a class="btn" href="/console.html" target="_blank"
            style="position: relative; top: -20px; margin-top: 4px">Console</a>
        </div>
      </aside>
      <main class="content">
        <section class="toolbar">
          <button @click="goUp">Back</button>
          <div style="position:relative; display:inline-block">
            <button @click.stop="newMenu.visible = !newMenu.visible">New ‚ñæ</button>
            <div v-if="newMenu.visible" class="dropdown-menu">
              <div class="menu-item" @click="createFolder(); newMenu.visible = false">New Folder</div>
              <div class="menu-item" @click="createFile(); newMenu.visible = false">New File</div>
            </div>
          </div>
          <label class="upload">
            <input type="file" @change="onUpload" multiple />
            <span>Upload Files</span>
          </label>
          <label class="upload">
            <input type="file" @change="onUpload" multiple webkitdirectory />
            <span>Upload Folder</span>
          </label>
          <button v-if="clipboard.item" @click="pasteHere">Paste</button>
          <button v-if="selected.size > 0" @click="downloadSelected">Download Selected ({{ selected.size }})</button>
          <button v-if="undoToken" @click="undo">Undo</button>
          <span class="spacer"></span>
          <button @click="toggleViewMode">{{ viewMode === 'list' ? '‚äû Grid' : '‚â£ List' }}</button>
          <div class="search-box">
            <label style="font-size:12px; margin-right:4px; display:flex; align-items:center"
              title="Deep recursive search">
              <input type="checkbox" v-model="deepSearch" /> Deep
            </label>
            <input v-model="filterText" @keyup.enter="performSearch" placeholder="Search..."
              style="border:none; outline:none; background:transparent; max-width:180px; color:inherit" />
          </div>
          <span class="muted" style="font-size:12px">Page {{ page }} / {{ totalPages }}</span>
        </section>

        <section class="listing" @contextmenu.prevent="openBlankMenu($event)">
          <!-- List View -->
          <table v-if="viewMode === 'list'">
            <thead>
              <tr>
                <th>Name</th>
                <th>Size</th>
                <th>Modified</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(e, idx) in paginatedEntries" :key="e.path" :class="{ selected: isSelected(e) }"
                @click="onRowClick($event, e, idx)" @contextmenu.prevent="openContextMenu($event, e)" draggable="true"
                @dragstart="onDragStart($event, e)" @dragend="onDragEnd"
                @dragover.prevent="e.is_dir && onDragOver($event)" @dragleave="e.is_dir && onDragLeave($event)"
                @drop="e.is_dir && onDrop($event, e)">
                <td>
                  <span v-if="e.is_dir" class="folder" @dblclick="openDir(e)">üìÅ {{ e.name }}</span>
                  <span v-else class="file" @dblclick="preview(e)">üìÑ {{ e.name }}</span>
                </td>
                <td>{{ e.is_dir ? '' : formatSize(e.size) }}</td>
                <td>{{ formatTime(e.modified) }}</td>
              </tr>
            </tbody>
          </table>

          <!-- Grid View -->
          <div v-else class="grid-view">
            <div v-for="(e, idx) in paginatedEntries" :key="e.path" class="grid-item"
              :class="{ selected: isSelected(e) }" @click="onRowClick($event, e, idx)" @dblclick="onItemDblClick(e)"
              @contextmenu.prevent="openContextMenu($event, e)" draggable="true" @dragstart="onDragStart($event, e)">
              <div class="grid-icon" v-if="!isImage(e.name)">{{ e.is_dir ? 'üìÅ' : 'üìÑ' }}</div>
              <div class="grid-icon" v-else>
                <img :src="'/api/thumb?path=' + encodeURIComponent(e.path)" loading="lazy"
                  style="width:48px; height:48px; object-fit:cover; border-radius:4px" />
              </div>
              <div class="grid-name">{{ e.name }}</div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <!-- System Monitor Bar -->
    <div class="system-bar">
      <div class="stat-item"><strong>CPU:</strong> {{ stats.cpu }}%</div>
      <div class="stat-item"><strong>RAM:</strong> {{ stats.mem_used }} / {{ stats.mem_total }} ({{ stats.mem_pct }}%)
      </div>
      <div class="stat-item"><strong>Disk:</strong> {{ stats.disk_free }} Free ({{ stats.disk_pct }}% Used)</div>
      <span style="flex:1"></span>
      <div v-if="wsStatus" class="stat-item" style="color: green">‚óè Connected</div>
      <div v-else class="stat-item" style="color: red">‚óè Disconnected</div>
    </div>

    <!-- Upload Progress -->
    <div v-if="uploading.active" class="upload-overlay">
      <div style="font-weight:600; margin-bottom:4px">Uploading...</div>
      <div style="font-size:12px">{{ uploading.currentFile }}</div>
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: uploading.percent + '%' }"></div>
      </div>
      <div style="font-size:12px; margin-top:4px; text-align:right">{{ uploading.percent }}%</div>
    </div>

    <div v-if="menu.visible" class="context-menu" :style="{ left: menu.x + 'px', top: menu.y + 'px' }" @click.stop>
      <template v-if="menu.item">
        <div class="menu-item" @click="cmOpen(menu.item)">Open</div>
        <div class="menu-item" v-if="isTextFile(menu.item)" @click="cmEdit(menu.item)">Edit</div>
        <div class="menu-item" @click="pin(menu.item.path)">Pin</div>
        <div class="menu-item" @click="cmCopy(menu.item)">Copy</div>
        <div class="menu-item" @click="cmCut(menu.item)">Cut</div>
        <div class="menu-item" v-if="!menu.item?.is_dir" @click="cmDownload(menu.item)">Download</div>
        <div class="menu-item" v-if="menu.item?.is_dir" @click="cmZipDownload(menu.item)">Download (ZIP)</div>
        <div class="menu-item" v-if="menu.item?.is_dir" @click="cmZipDownload(menu.item, true)">Download (Fast ZIP)
        </div>
        <div class="menu-item" v-if="!menu.item?.is_dir" @click="preview(menu.item)">Preview</div>
        <div class="menu-item" @click="openProperties(menu.item)">Properties</div>
        <div class="menu-item" @click="openShare(menu.item)">Share</div>
        <div class="menu-item" @click="cmRename(menu.item)">Rename</div>
        <div class="menu-item danger" @click="cmDelete(menu.item)">Delete</div>
        <div class="menu-sep"></div>
      </template>
      <details open>
        <summary>New</summary>
        <div class="menu-sub">
          <div class="menu-item" @click="createFolder">Folder</div>
          <div class="menu-item" @click="createFile">File</div>
        </div>
      </details>
    </div>
    <!-- Share Modal -->
    <div v-if="share.visible" class="modal" @click.self="closeShare">
      <div class="modal-card" style="max-width:720px;width:80vw;height:auto;">
        <div class="modal-head">
          <strong>Share: {{ share.item?.name }}</strong>
          <button @click="closeShare">Close</button>
        </div>
        <div style="padding:12px; display:grid; gap:12px;">
          <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
            <label><input type="radio" value="readonly" v-model="share.access" /> Readonly</label>
            <label><input type="radio" value="edit" v-model="share.access" /> Edit</label>
            <label><input type="checkbox" v-model="share.allowDownload" /> Allow download</label>
          </div>

          <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
            <label>Expire (hours): <input type="number" min="0" step="1" v-model.number="share.expiresHours"
                :disabled="share.noExpiry" style="width:100px" /></label>
            <label><input type="checkbox" v-model="share.noExpiry" /> No expiry</label>
          </div>
          <div style="display:flex; gap:8px;">
            <button @click="createShareLink" :disabled="share.generating">Generate link</button>
            <span v-if="share.generating">Generating...</span>
          </div>
          <div v-if="share.url">
            <div style="font-size:12px; color:#6b7280; margin-bottom:4px">Share link:</div>
            <div style="display:flex; gap:8px;">
              <input :value="share.url" readonly style="flex:1; padding:6px 8px;" />
              <button @click="copyShare">Copy</button>
            </div>
            <div v-if="share.expiresAt" style="font-size:12px; color:#6b7280; margin-top:6px">Expires at: {{
              formatExpire(share.expiresAt) }}</div>
          </div>
        </div>
      </div>
    </div>
    <!-- Editor/Preview Modal -->
    <div v-if="editor.visible" class="modal" @click.self="closeEditor">
      <!-- Text Editor (IDE Mode) -->
      <div v-if="editor.type === 'text'" class="modal-card modal-ide">
        <div class="modal-head">
          <span style="display:flex; gap:10px; align-items:center">
            {{ editor.name }} <span v-if="editor.editable && !editor.cm?.options?.readOnly"
              style="opacity:0.6; font-weight:normal">‚Äî Edited</span>
          </span>
          <div style="display:flex; gap:12px; align-items:center">
            <button @click="editor.editable = !editor.editable; applyEditorReadonly()"
              :style="{ background: editor.editable ? '#333' : 'transparent', border: '1px solid ' + (editor.editable ? '#0e639c' : '#444'), color: editor.editable ? '#fff' : '#888', padding: '3px 8px', borderRadius: '3px', cursor: 'pointer', fontSize: '11px', transition: 'all 0.2s' }">
              {{ editor.editable ? 'Edit Mode' : 'Read-only' }}
            </button>
            <button v-if="editor.editable" @click="saveEditor"
              style="background:#0e639c; color:white; border:none; padding:4px 10px; border-radius:3px; cursor:pointer; font-size:12px">Save</button>
            <button @click="closeEditor"
              style="background:transparent; border:none; color:inherit; font-weight:bold; font-size:16px; cursor:pointer; padding:0 4px">‚úï</button>
          </div>
        </div>
        <div class="modal-body" style="display:flex; flex-direction:column; padding:0; overflow:hidden">
          <div id="cm-host" class="code-container" style="flex:1"></div>
        </div>
      </div>

      <!-- Media Previews (Standard Modal) -->
      <div v-else class="modal-card" style="width: 90vw; height: 90vh; max-width: none;">
        <div class="modal-head">
          <strong>{{ editor.name }}</strong>
          <button @click="closeEditor">Close</button>
        </div>
        <div class="modal-body"
          style="flex:1; display:flex; align-items:center; justify-content:center; padding:0; overflow:auto">

          <div v-if="editor.type==='image'"
            style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;">
            <img :src="editor.url" :alt="editor.name" style="max-width:100%; max-height:100%; object-fit:contain"
              @error="onPreviewError" />
          </div>

          <iframe v-else-if="editor.type==='pdf'" :src="editor.url" type="application/pdf"
            style="width:100%; height:100%; border:none" onerror="this.__vue_onerror && this.__vue_onerror()"></iframe>

          <div v-else-if="editor.type==='audio'" style="padding:20px">
            <audio :src="editor.url" controls style="width:100%" @error="onPreviewError"></audio>
          </div>

          <div v-else-if="editor.type==='video'"
            style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;">
            <video :src="editor.url" controls style="max-width:100%; max-height:100%" @error="onPreviewError"></video>
          </div>

          <div v-else style="text-align:center; color:#6b7280; padding:20px">
            <p>Preview not available.</p>
            <button @click="cmDownload({ path: editor.path, name: editor.name })">Download</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Input Modal (Command Palette Style) -->
    <div v-if="inputModal.visible" class="modal" @click.self="resolveInput(null)">
      <div class="modal-input modal-card" style="width:400px; height:auto; overflow:visible">
        <!-- override modal-card default size -->
        <h3>{{ inputModal.title }}</h3>
        <input id="modal-input-field" v-model="inputModal.value" @keyup.enter="resolveInput(inputModal.value)"
          @keyup.esc="resolveInput(null)" placeholder="Enter name..." />
        <div class="btns">
          <button @click="resolveInput(null)">Cancel</button>
          <button @click="resolveInput(inputModal.value)"
            style="background:#0e639c; color:white; border:none">OK</button>
        </div>
      </div>
    </div>

    <!-- Properties Modal -->
    <div v-if="propsModal.visible" class="modal" @click.self="closeProperties">
      <div class="modal-card" style="max-width:560px; width:80vw; height:auto">
        <div class="modal-head">
          <strong>Properties: {{ propsModal.data?.name || '' }}</strong>
          <button @click="closeProperties">Close</button>
        </div>
        <div style="padding:12px; display:grid; gap:10px">
          <div><strong>Path:</strong> <span style="word-break:break-all">{{ propsModal.data?.path }}</span></div>
          <div><strong>Type:</strong> {{ propsModal.data?.is_dir ? 'Folder' : 'File' }}</div>
          <div><strong>Size:</strong> {{ propsModal.data ? (propsModal.data.is_dir ? '' :
            formatSize(propsModal.data.size)) : '' }}</div>
          <div><strong>Modified:</strong>
            <input type="datetime-local" :value="propsModifiedLocal" @change="onPropsModifiedChange($event)" />
          </div>
          <div><label><input type="checkbox" v-model="propsModal.readonly" /> Readonly</label></div>
          <div style="display:flex; gap:8px; justify-content:flex-end">
            <button @click="saveProperties">Save</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const { createApp, ref, onMounted, reactive, computed, nextTick, watch } = Vue
    createApp({
      setup() {
        const currentPath = ref('C:\\')
        const entries = ref([])
        const menu = reactive({ visible: false, x: 0, y: 0, item: null })
        const clipboard = reactive({ item: null, mode: null })
        const editor = reactive({ visible: false, path: '', name: '', content: '', editable: false, type: '', url: '' })
        const propsModal = reactive({ visible: false, item: null, data: null, readonly: false, modified: null })
        const selected = reactive(new Set())
        let lastClickedIndex = -1
        const dragging = reactive({ active: false, items: [] })
        const undoToken = ref('')
        const pins = ref([])
        const drives = ref([])
        const share = reactive({ visible: false, item: null, access: 'readonly', allowDownload: true, noExpiry: true, expiresHours: 24, url: '', generating: false, expiresAt: null })
        const sidebarEl = ref(null)
        const filterText = ref('')
        const page = ref(1)
        const pageSize = ref(100)
        const theme = ref('light')

        // New States
        const viewMode = ref('list')
        const deepSearch = ref('false')
        const uploading = reactive({ active: false, currentFile: '', percent: 0 })
        const stats = reactive({ cpu: 0, mem_used: 0, mem_total: 0, mem_pct: 0, disk_free: 0, disk_pct: 0 })
        const wsStatus = ref(false)
        let ws = null
        const showDropOverlay = ref(false)
        let dragCounter = 0

        // Drag & Drop / Upload Logic
        async function handleFiles(files) {
          if (!files || files.length === 0) return
          uploading.active = true
          try {
            for (let i = 0; i < files.length; i++) {
              const file = files[i]
              uploading.currentFile = file.name
              uploading.percent = 0
              const form = new FormData()
              form.append('file', file)
              if (file.webkitRelativePath) {
                form.append('rel_path', file.webkitRelativePath)
              }

              await axios.post('/api/upload', form, {
                params: { dest: currentPath.value },
                onUploadProgress: (progressEvent) => {
                  const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                  uploading.percent = percent;
                }
              })
            }
            await load(currentPath.value)
          } catch (err) {
            alert('Upload failed: ' + err.message)
          } finally {
            uploading.active = false
          }
        }

        async function onUpload(ev) {
          const input = ev.target
          if (input.files) {
            await handleFiles(input.files)
            input.value = ''
          }
        }

        function setupDragDrop() {
          window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            showDropOverlay.value = true;
          });
          window.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter <= 0) {
              dragCounter = 0;
              showDropOverlay.value = false;
            }
          });
          window.addEventListener('dragover', (e) => {
            e.preventDefault();
            showDropOverlay.value = true;
          });
          window.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            showDropOverlay.value = false;
            if (e.dataTransfer && e.dataTransfer.files) {
              await handleFiles(e.dataTransfer.files)
            }
          });
        }

        // Input Modal Logic
        const newMenu = reactive({ visible: false })
        const inputModal = reactive({ visible: false, title: '', value: '', resolve: null })
        function showInput(title, defaultValue = '') {
          return new Promise(resolve => {
            inputModal.title = title
            inputModal.value = defaultValue
            inputModal.visible = true
            inputModal.resolve = resolve
            nextTick(() => document.getElementById('modal-input-field')?.focus())
          })
        }
        function resolveInput(val) {
          inputModal.visible = false
          if (inputModal.resolve) inputModal.resolve(val)
          inputModal.resolve = null
        }

        // Monaco Logic
        let monacoEditor = null

        function initMonaco() {
          return new Promise((resolve) => {
            if (window.monaco) return resolve()
            require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.44.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
              resolve()
            });
          })
        }

        async function createMonaco(content, readOnly, language) {
          await initMonaco()
          const host = document.getElementById('cm-host') // reuse same ID for container
          if (!host) return

          // Dispose old if exists
          if (monacoEditor) {
            monacoEditor.dispose()
            monacoEditor = null
          }
          host.innerHTML = '' // clear any debris

          monacoEditor = monaco.editor.create(host, {
            value: content,
            language: language || 'plaintext',
            theme: 'vs-dark', // Force Dark Theme for IDE look
            readOnly: readOnly,
            automaticLayout: true,
            minimap: { enabled: true },
            scrollBeyondLastLine: false,
            fontSize: 14,
            padding: { top: 10, bottom: 10 }
          })
        }

        function getMonacoLanguage(filename) {
          const ext = filename.split('.').pop().toLowerCase()
          const map = {
            'js': 'javascript', 'ts': 'typescript', 'py': 'python', 'html': 'html', 'css': 'css',
            'json': 'json', 'md': 'markdown', 'xml': 'xml', 'sql': 'sql', 'sh': 'shell',
            'bat': 'bat', 'java': 'java', 'c': 'c', 'cpp': 'cpp', 'go': 'go', 'rs': 'rust',
            'php': 'php', 'rb': 'ruby', 'yml': 'yaml', 'yaml': 'yaml', 'ini': 'ini'
          }
          return map[ext] || 'plaintext'
        }

        async function load(path) {
          try {
            const res = await axios.get('/api/list', { params: { path } })
            entries.value = res.data
            currentPath.value = path
            try { localStorage.setItem('rfe:lastPath', path) } catch { }
            page.value = 1
            updateWatcher(path)
          } catch (err) {
            const msg = err?.response?.data?.detail || err?.message || 'Unknown error'
            alert('Kh√¥ng th·ªÉ truy c·∫≠p th∆∞ m·ª•c n√†y: ' + msg)
          }
        }

        async function performSearch() {
          if (deepSearch.value && filterText.value.trim().length > 0) {
            try {
              entries.value = [] // Clear for visual feedback
              const res = await axios.post('/api/search', { path: currentPath.value, query: filterText.value })
              entries.value = res.data
              page.value = 1
            } catch (err) {
              alert('Search failed: ' + err.message)
            }
          }
          // Normal filter handled by computed prop 'filteredEntries' if deepSearch is false
        }

        // Watcher Logic
        function initWatcher() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/api/ws/watcher`;
          ws = new WebSocket(wsUrl);

          ws.onopen = () => {
            wsStatus.value = true
            if (currentPath.value) updateWatcher(currentPath.value)
          };
          ws.onmessage = (ev) => {
            if (ev.data === 'change') {
              // Reload current path silently
              load(currentPath.value)
            }
          };
          ws.onclose = () => { wsStatus.value = false; setTimeout(initWatcher, 3000) };
          ws.onerror = () => { ws.close() };
        }

        function updateWatcher(path) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: 'watch', path }))
          }
        }

        // Monitoring Logic
        async function fetchStats() {
          try {
            const res = await axios.get('/api/monitor/stats', { params: { path: currentPath.value } })
            const d = res.data
            stats.cpu = d.cpu_percent
            stats.mem_pct = d.memory_percent
            stats.mem_used = formatSize(d.memory_used)
            stats.mem_total = formatSize(d.memory_total)
            stats.disk_free = formatSize(d.disk_free)
            stats.disk_pct = d.disk_percent
          } catch { }
        }

        function displayName(p) { return p }
        async function fetchPins() {
          try {
            const res = await axios.get('/api/pins')
            if (Array.isArray(res.data)) pins.value = res.data
          } catch (err) {
            alert('Kh√¥ng th·ªÉ t·∫£i danh s√°ch pin: ' + (err.response?.data?.detail || err.message))
          }
        }
        async function pin(path) {
          try {
            await axios.post('/api/pins', { path })
            await fetchPins()
          } catch (err) {
            alert('Kh√¥ng th·ªÉ pin: ' + (err.response?.data?.detail || err.message))
          }
        }
        async function unpin(path) {
          try {
            await axios.delete('/api/pins', { params: { path } })
            await fetchPins()
          } catch (err) {
            alert('Kh√¥ng th·ªÉ b·ªè pin: ' + (err.response?.data?.detail || err.message))
          }
        }
        function onSidebarDragOver(ev) { ev.currentTarget.classList.add('dragover') }
        function onSidebarDragLeave(ev) { ev.currentTarget.classList.remove('dragover') }
        async function onSidebarDrop(ev) {
          ev.currentTarget.classList.remove('dragover')
          // Prefer first selected folder; fallback to currentPath
          const folder = entries.value.find(e => selected.has(e.path) && e.is_dir)
          if (folder) await pin(folder.path)
        }
        function navigate(path) { load(path) }
        function goUp() {
          const p = currentPath.value.replace(/\\+$/, '')
          const idx = p.lastIndexOf('\\')
          if (idx > 2) load(p.slice(0, idx)); else load(p.slice(0, 3))
        }
        function openDir(e) { if (e.is_dir) load(e.path) }
        function getFileTypeByName(name) {
          const lower = name.toLowerCase(); const ext = lower.split('.').pop()
          const text = ['txt', 'md', 'log', 'json', 'xml', 'csv', 'ini', 'conf', 'yaml', 'yml', 'py', 'js', 'ts', 'java', 'c', 'cpp', 'cs', 'go', 'rb', 'php', 'bat', 'ps1', 'html', 'css', 'sql', 'sh']
          if (text.includes(ext)) return 'text'
          const img = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico']
          if (img.includes(ext)) return 'image'
          if (ext === 'pdf') return 'pdf'
          const aud = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'flac']
          if (aud.includes(ext)) return 'audio'
          const vid = ['mp4', 'webm', 'ogv', 'mkv', 'mov']
          if (vid.includes(ext)) return 'video'
          return 'other'
        }
        function isImage(name) { return getFileTypeByName(name) === 'image' }

        async function downloadFile(e) {
          const url = `/api/file?path=${encodeURIComponent(e.path)}`
          const a = document.createElement('a')
          a.href = url; a.download = e.name; a.click()
        }
        async function downloadSelected() {
          if (selected.size === 0) return
          const selectedItems = Array.from(selected).map(path => entries.value.find(e => e.path === path)).filter(Boolean)
          if (selectedItems.length === 0) return

          // If only one item selected, download directly
          if (selectedItems.length === 1) {
            const item = selectedItems[0]
            if (item.is_dir) {
              // Download folder as ZIP
              const url = `/api/zip?path=${encodeURIComponent(item.path)}`
              const a = document.createElement('a')
              a.href = url; a.download = `${item.name}.zip`; a.click()
            } else {
              // Download single file
              downloadFile(item)
            }
            return
          }

          // Multiple items selected - create a temporary ZIP
          try {
            const paths = selectedItems.map(item => item.path)
            const response = await axios.post('/api/zip/multiple', { paths }, { responseType: 'blob' })
            const url = window.URL.createObjectURL(new Blob([response.data]))
            const a = document.createElement('a')
            a.href = url; a.download = 'selected_files.zip'; a.click()
            window.URL.revokeObjectURL(url)
          } catch (err) {
            alert('Failed to download selected files: ' + (err.response?.data?.detail || err.message))
          }
        }

        // promptNew removed (replaced by dropdown)
        async function promptRename(e) {
          const newName = await showInput('Rename', e.name)
          if (!newName || newName === e.name) return
          await axios.post('/api/rename', { path: e.path, new_name: newName })
          await load(currentPath.value)
        }
        async function deletePath(e) {
          if (!window.confirm(`Delete ${e.name}?`)) return
          await axios.post('/api/delete', { path: e.path })
          await load(currentPath.value)
        }
        function isSelected(e) { return selected.has(e.path) }
        function clearSelection() { selected.clear(); lastClickedIndex = -1 }
        function onRowClick(ev, e, idx) {
          const isCtrl = ev.ctrlKey || ev.metaKey
          const isShift = ev.shiftKey
          if (isShift && lastClickedIndex >= 0) {
            const [a, b] = idx > lastClickedIndex ? [lastClickedIndex, idx] : [idx, lastClickedIndex]
            selected.clear()
            for (let i = a; i <= b; i++) selected.add(entries.value[i].path)
          } else if (isCtrl) {
            if (selected.has(e.path)) selected.delete(e.path); else selected.add(e.path)
            lastClickedIndex = idx
          } else {
            selected.clear(); selected.add(e.path); lastClickedIndex = idx
          }
        }
        function onDragStart(ev, e) {
          // if the dragged item isn't selected, select it first
          if (!selected.has(e.path)) { selected.clear(); selected.add(e.path) }
          dragging.active = true
          dragging.items = Array.from(selected)
          ev.dataTransfer.effectAllowed = 'move'
        }
        function onDragEnd() { dragging.active = false; dragging.items = [] }
        function onDragOver(ev) { ev.currentTarget.classList.add('drop-target') }
        function onDragLeave(ev) { ev.currentTarget.classList.remove('drop-target') }
        async function onDrop(ev, folder) {
          ev.currentTarget.classList.remove('drop-target')
          if (!folder || !folder.is_dir) return
          const destination = folder.path
          for (const src of dragging.items) {
            if (samePath(src, destination) || isChildOf(destination, src)) continue
            const res = await axios.post('/api/move', { source: src, destination })
            if (res.data?.undo_token) undoToken.value = res.data.undo_token
          }
          await load(currentPath.value)
        }
        async function undo() {
          if (!undoToken.value) return
          await axios.post('/api/undo', { token: undoToken.value })
          undoToken.value = ''
          await load(currentPath.value)
        }
        function samePath(a, b) { return normalize(a) === normalize(b) }
        function isChildOf(child, parent) { const A = normalize(child); const B = normalize(parent); return A.startsWith(B + '\\') }
        function normalize(p) { return p.replace(/\\+/g, '\\').replace(/\\$/, '').toLowerCase() }
        function openContextMenu(ev, item) {
          menu.visible = true; menu.x = ev.pageX; menu.y = ev.pageY; menu.item = item
          document.addEventListener('click', () => { menu.visible = false }, { once: true })
        }
        function openBlankMenu(ev) {
          // Only trigger when clicking whitespace, not on row (row handler stops propagation)
          if (ev.target.closest('tr') || ev.target.closest('.grid-item')) return
          menu.visible = true; menu.x = ev.pageX; menu.y = ev.pageY; menu.item = null
          document.addEventListener('click', () => { menu.visible = false }, { once: true })
        }
        function isTextFile(item) {
          if (!item || item.is_dir) return false
          const exts = ['.txt', '.md', '.log', '.json', '.xml', '.csv', '.ini', '.conf', '.cfg', '.yaml', '.yml', '.toml', '.properties', '.reg', '.vbs', '.py', '.js', '.ts', '.java', '.c', '.cpp', '.cs', '.go', '.rb', '.php', '.bat', '.cmd', '.ps1', '.html', '.css', '.sql', '.sh']
          const name = item.name.toLowerCase()
          return exts.some(e => name.endsWith(e))
        }
        function cmOpen(item) {
          if (!item) return
          if (!item.is_dir) {
            window.open(`/api/open?path=${encodeURIComponent(item.path)}`, '_blank')
          } else {
            openDir(item)
          }
        }
        async function cmEdit(item) {
          if (!item || item.is_dir) return
          const res = await axios.get('/api/read', { params: { path: item.path }, responseType: 'text' })
          editor.visible = true; editor.path = item.path; editor.name = item.name; editor.type = 'text'; editor.content = res.data; editor.editable = false
          await nextTick()
          await createMonaco(editor.content, false, getMonacoLanguage(item.name))
        }

        async function preview(item) {
          if (!item || item.is_dir) return
          const ftype = getFileTypeByName(item.name)
          editor.visible = true; editor.path = item.path; editor.name = item.name; editor.type = ftype; editor.editable = false

          if (ftype === 'text') {
            const res = await axios.get('/api/read', { params: { path: item.path }, responseType: 'text' })
            editor.content = res.data
            await nextTick()
            await createMonaco(editor.content, true, getMonacoLanguage(item.name))
          } else if (ftype === 'image' || ftype === 'pdf' || ftype === 'audio' || ftype === 'video') {
            editor.url = `/api/open?path=${encodeURIComponent(item.path)}`
          } else {
            try {
              const res = await axios.get('/api/read', { params: { path: item.path }, responseType: 'text' })
              editor.type = 'text'; editor.content = res.data
              await nextTick()
              await createMonaco(editor.content, true, getMonacoLanguage(item.name))
            } catch (e) {
              alert('Cannot preview this file.'); editor.visible = false
            }
          }
        }
        function cmCopy(item) { clipboard.item = item; clipboard.mode = 'copy' }
        function cmCut(item) { clipboard.item = item; clipboard.mode = 'cut' }
        async function pasteHere() {
          if (!clipboard.item || !clipboard.mode) return
          const target = currentPath.value
          try {
            if (clipboard.mode === 'copy') {
              await axios.post('/api/copy', { source: clipboard.item.path, destination: target })
            } else {
              const res = await axios.post('/api/move', { source: clipboard.item.path, destination: target })
              if (res.data?.undo_token) undoToken.value = res.data.undo_token
            }
          } finally {
            clipboard.item = null; clipboard.mode = null
          }
          await load(currentPath.value)
        }
        function cmDownload(item) {
          if (!item || item.is_dir) return
          const a = document.createElement('a')
          a.href = `/api/file?path=${encodeURIComponent(item.path)}`
          a.download = item.name
          a.click()
        }
        function cmZipDownload(item, fast = false) {
          if (!item || !item.is_dir) return
          const a = document.createElement('a')
          a.href = `/api/zip?path=${encodeURIComponent(item.path)}&fast=${fast ? 'true' : 'false'}`
          a.download = item.name + '.zip'
          a.click()
        }
        function openShare(item) { share.visible = true; share.item = item; share.url = ''; share.expiresAt = null }
        function closeShare() { share.visible = false }
        async function createShareLink() {
          if (!share.item) return
          share.generating = true
          try {
            const body = {
              path: share.item.path,
              readonly: share.access === 'readonly',
              allow_edit: share.access === 'edit',
              allow_download: !!share.allowDownload,
              expires_hours: share.noExpiry ? null : (share.expiresHours || null),
            }
            const res = await axios.post('/api/share/create', body)
            share.url = res.data?.url || ''
            share.expiresAt = res.data?.expires_at || null
          } finally {
            share.generating = false
          }
        }
        async function copyShare() {
          try { await navigator.clipboard.writeText(share.url) } catch { }
        }
        async function cmRename(item) { await promptRename(item) }
        async function cmDelete(item) { await deletePath(item) }
        async function createFolder() {
          const name = await showInput('New Folder Name')
          if (!name) return
          await axios.post('/api/mkdir', { path: join(currentPath.value, name) })
          await load(currentPath.value)
        }
        async function createFile() {
          const name = await showInput('New File Name')
          if (!name) return
          await axios.post('/api/save', { path: join(currentPath.value, name), content: '' })
          await load(currentPath.value)
        }
        function applyEditorReadonly() {
          if (monacoEditor) monacoEditor.updateOptions({ readOnly: !editor.editable })
        }

        async function saveEditor() {
          if (monacoEditor) editor.content = monacoEditor.getValue()
          await axios.post('/api/save', { path: editor.path, content: editor.content })
          editor.editable = false
          applyEditorReadonly()
        }

        function closeEditor() {
          editor.visible = false
          if (monacoEditor) {
            monacoEditor.dispose()
            monacoEditor = null
          }
        }
        function join(a, b) { return a.endsWith('\\') ? a + b : a + '\\' + b }
        function formatSize(bytes) {
          const thresh = 1024; if (Math.abs(bytes) < thresh) return bytes + ' B'
          const units = ['KB', 'MB', 'GB', 'TB', 'PB']; let u = -1
          do { bytes /= thresh; u++ } while (Math.abs(bytes) >= thresh && u < units.length - 1)
          return bytes.toFixed(1) + ' ' + units[u]
        }
        function formatTime(epoch) { return new Date(epoch * 1000).toLocaleString() }
        function formatExpire(ts) { try { return new Date(ts * 1000).toLocaleString() } catch { return '' } }

        const filteredEntries = computed(() => {
          // If deep search happened, entries already contains filtered result from backend
          if (deepSearch.value && filterText.value.length > 0) return entries.value

          const q = filterText.value.trim().toLowerCase()
          if (!q) return entries.value
          return entries.value.filter(e => e.name.toLowerCase().includes(q))
        })

        const totalPages = computed(() => Math.max(1, Math.ceil(filteredEntries.value.length / pageSize.value)))
        const paginatedEntries = computed(() => {
          const start = (page.value - 1) * pageSize.value
          return filteredEntries.value.slice(start, start + pageSize.value)
        })
        function nextPage() { if (page.value < totalPages.value) page.value++ }
        function prevPage() { if (page.value > 1) page.value-- }
        const pathSegments = computed(() => {
          const p = currentPath.value.replace(/\\+$/, '')
          if (!/^[A-Za-z]:\\/.test(p)) return []
          const parts = p.split('\\').filter(Boolean)
          const segs = []
          let accum = ''
          for (let i = 0; i < parts.length; i++) {
            if (i === 0) {
              accum = parts[0] + '\\'
              segs.push({ label: parts[0] + '\\', path: accum })
            } else {
              accum = accum.endsWith('\\') ? accum + parts[i] : accum + '\\' + parts[i]
              segs.push({ label: parts[i], path: accum })
            }
          }
          return segs
        })
        function toggleTheme() {
          theme.value = theme.value === 'dark' ? 'light' : 'dark'
          try { localStorage.setItem('rfe:theme', theme.value) } catch { }
          document.body.classList.toggle('dark', theme.value === 'dark')
          if (monacoEditor) {
            monaco.editor.setTheme(theme.value === 'dark' ? 'vs-dark' : 'vs')
          }
        }
        function toggleViewMode() {
          viewMode.value = viewMode.value === 'list' ? 'grid' : 'list'
          try { localStorage.setItem('rfe:viewMode', viewMode.value) } catch { }
        }

        function onPreviewError() { alert('Cannot preview this file. Please download and open locally.'); editor.visible = false }
        try { Object.defineProperty(window, '__vue_onerror', { value: onPreviewError }) } catch { }
        function toLocalDateTimeInput(ts) {
          try { const d = new Date(ts * 1000); const pad = n => String(n).padStart(2, '0'); return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}` } catch { return '' }
        }
        function fromLocalDateTimeInput(val) {
          try { const d = new Date(val); return Math.floor(d.getTime() / 1000) } catch { return null }
        }
        async function openProperties(item) {
          if (!item) return
          propsModal.visible = true; propsModal.item = item; propsModal.data = null
          try {
            const res = await axios.get('/api/stat', { params: { path: item.path } })
            propsModal.data = res.data
            propsModal.readonly = !!res.data?.readonly
            propsModal.modified = res.data?.modified || null
          } catch (err) {
            alert('Failed to load properties: ' + (err.response?.data?.detail || err.message))
          }
        }
        function closeProperties() { propsModal.visible = false }
        const propsModifiedLocal = computed(() => propsModal.data ? toLocalDateTimeInput(propsModal.modified || propsModal.data.modified) : '')
        function onPropsModifiedChange(ev) { const v = ev.target.value; const ts = fromLocalDateTimeInput(v); if (ts) propsModal.modified = ts }
        async function saveProperties() {
          if (!propsModal.item) return
          try {
            await axios.post('/api/update_meta', { path: propsModal.item.path, modified: propsModal.modified, readonly: propsModal.readonly })
            await openProperties(propsModal.item)
          } catch (err) {
            alert('Failed to save properties: ' + (err.response?.data?.detail || err.message))
          }
        }
        onMounted(async () => {
          setupDragDrop()
          let initial = currentPath.value
          try {
            const saved = localStorage.getItem('rfe:lastPath')
            if (saved) initial = saved
          } catch { }

          try {
            const savedView = localStorage.getItem('rfe:viewMode')
            if (savedView) viewMode.value = savedView
          } catch { }

          await load(initial)

          try {
            const res = await axios.get('/api/roots')
            if (Array.isArray(res.data)) drives.value = res.data
          } catch { }
          await fetchPins()
          try {
            const t = localStorage.getItem('rfe:theme')
            if (t === 'dark') { theme.value = 'dark'; document.body.classList.add('dark') }
          } catch { }

          initWatcher()

          // Poll system stats
          fetchStats()
          setInterval(fetchStats, 5000)

          window.addEventListener('keydown', (ev) => {
            const tag = (ev.target && ev.target.tagName) ? ev.target.tagName.toLowerCase() : ''
            const isTyping = tag === 'input' || tag === 'textarea'
            if (ev.key === 'Enter') {
              if (isTyping) return // Let input handle enter (search etc)
              const first = entries.value.find(e => selected.has(e.path))
              if (first) { ev.preventDefault(); first.is_dir ? openDir(first) : cmOpen(first) }
            }
            if (ev.key === 'Backspace' && !isTyping) {
              ev.preventDefault();
              goUp()
            }
            if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'c') {
              const first = entries.value.find(e => selected.has(e.path))
              if (first) { ev.preventDefault(); cmCopy(first) }
            }
            if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'x') {
              const first = entries.value.find(e => selected.has(e.path))
              if (first) { ev.preventDefault(); cmCut(first) }
            }
            if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'v') {
              ev.preventDefault(); pasteHere()
            }
            if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
              ev.preventDefault();
              undo()
            }
          })
        })
        return { currentPath, entries, navigate, goUp, openDir, downloadFile, downloadSelected, onUpload, deletePath, formatSize, formatTime, openContextMenu, openBlankMenu, menu, cmOpen, cmEdit, cmCopy, cmCut, cmDownload, cmZipDownload, cmRename, cmDelete, clipboard, pasteHere, createFolder, createFile, editor, saveEditor, closeEditor, isTextFile, isSelected, onRowClick, onDragStart, onDragEnd, onDragOver, onDragLeave, onDrop, undoToken, undo, pins, drives, displayName, pin, unpin, onSidebarDragOver, onSidebarDragLeave, onSidebarDrop, share, openShare, closeShare, createShareLink, copyShare, formatExpire, selected, filterText, page, pageSize, paginatedEntries, totalPages, pathSegments, theme, toggleTheme, preview, applyEditorReadonly, propsModal, openProperties, closeProperties, propsModifiedLocal, onPropsModifiedChange, saveProperties, onPreviewError, performSearch, viewMode, toggleViewMode, deepSearch, stats, uploading, wsStatus, isImage, inputModal, resolveInput, newMenu, promptRename, showDropOverlay }
      }
    }).mount('#app')
  </script>
</body>

</html>